1. 시계열데이터
2. 포트폴리오 최적화
	가장 좋은 포트폴리오
3. 자산 가격 결정 모델
	채권의 기본 개념
	금융 상품의 리스크
4. 파생상품 가격 결정->좀 어려움
	이산형, 연속형 기간 모델을 사용해 파생상품의 가격 결정
	파생상품의 리스크 측정하는 계측 값인 그릭
5. 신용 리스크 관리
	신용 부도 모델
	코플러를 사용해 부채와 사오간성은 가진 모델 구축

6. 금융
	현재 금융어들도 14세기 이탈리아에서 유래함

7. 자산
	실물자산
	  생산능력에 직접적으로 기여, 소득창출
	  예) 자동차 고앚ㅇ
	  ->금융자산을 제외한 자산으로 건물 토지 부동산과 도로, 자동차 등 운송장비, 가계부, 생활가전 
	금융자산
	  금융거래에는 대차관계가 발생하게 되는데 금융자산이란 이때의 금융적 청구권을 말한다. 
	  금융시장에서 이를 매개로 자금이 거래되므로 금융수단이라고도 한다.

8. 주식
9. 코스피
	->시가총액시: 시가총액이 큰 회사가 지수에 영향을 미친다. 원래는 나스닥식이였음
	krx
10. 다우존스
	30개의 우량 종목들을 선택해서 그것으로 지수를 만든다.
11. 나스닥
	
12. S&P500지수
	우량기업들 위주로 선정하여 지수를 만듦
13. 수정종가
14. 윈도드레싱
15. 채권
16. 채권의 종류
	발행처별
		국채
		지방채
		금융채
		회사채
	상환기간별
		단기채
		중기채
		장기채
	이자지급별
		이포채
		할인채
		복리채
		단기채
		거치채
	보증유무
		보증채
		무보증채
17. 기준금리
	금리를 낮추면 대출을 받기 수월해진다. 저축을 대신애 다른 대안을 한다.
	->즉 대출 비율에 영향
	->우리나라는 가계부채가 매우 높은 편이다. 따라서 금리를 높이면 문제가 될 수 있다.
	->중앙은행인 한국은행 안에 설치된 금융통화위원회에서 매달 회의를 통해 결정하는 금리이다.
18. 지급준비물
19. 출구전략
20. 파생증권
21. 파생금융상품
	본래 목적은 리스크를 낮추는 것.
22. 파생증권의 종류
	기초자산, 거래장소, 거래형태 등으로 분류
	기초자산
	거래형태
		선도- 
		선물-표준화된 계약조건으로 
		옵션- 장외 특정일 또는 일정기간내에 미리 정해진 가격으로 상품이나 유가증권 등의 특정자산을 사거나...
		스왑
	거래장소
		장내 거래
			거래소에서 거래-신용 리스크 없음
		장외 거래
			거래소 밖에서 거래하는 것-신용 리스크가 있음
23. 파생상품
	키코
	서브프라임모기지 사태
	종류
	파생상품의 활용
		거래적 해지
		전략적 해지
		자금조달비용 절감
		수익성 추구
	파생상품 거래 이유
		파생상품은 가격변동위험을 관리하는 효율적 수단을 제공
		유동성을 증가시켜 경쟁력을 통한 거래의 활성화 촉진
		시장의 효율성을 높임
		자본의 효율적 배분
		투자기회를 확대
24. 거래소시장
25. 장외시장(OTC)
26. 거래자 유형
	해저
		시장변수 변화로부터 직변하게 될 위험을 줄이기 위한 포지션
	투기자
		시장변수 변화로부터 이익을 얻기 위한 포지션
	차익거래자	
		2개 이상의 상품에 상쇄포지션을 취해 이익을 얻음
27. 파생상품의 위험성
	파생상품은 거래목적이 매우 다양하지만, 해저 또는 차익거래도
28. 금융시장의 기능
	자금 중개기능
	구체적 기능 6가지
		지금을 이전하는 수단을 제공
		거래를 위하여 결제수단을 제공
		리스크 관리의 수단을 제공
		자금의 축적 및 기업의 소유권을 다수의 소유자에게 분할하는 수단을 제공
		가격
	단기금융시장과 자본시장
	직접금융시장과 간접금융시장
		직접금융시장(채권 및 주식시장)
			자금의 공급자와 수요자가 계약당사자로서 직접 금융거래
			(미국, 영국에서 발달)
		간접금융시장
			금융기관이 자금공급자나 수요자를 대신하여 계약의 일방이 됨으로서 자금의 수요자와 공급자를 연결하는...
			(일본 독일에서 발달)
29. 자본시장의 구성
	채권시장
		채권이 거래되는 시장
		장외기장의 거래가 활발
	주식시장
		주식이 거래되는 시장
		유가증권시장, 코스닥시장, 프리보드시장
	파생상품시장
		통화, 채권, 주식, 금 등 기초자산의 가치변동에 의해 결정되는 금융거래가 이루어지는 시장
		-선도, 선물, 옵션, 스왑

30. 리스크에 대한 태도
	-위험 기피		
	-위험 선호
	-위험 중립
		리스크 상관 없다.

31. 주식
	보통주
		이익배당이나 잔여재산 분배등의 재산적 내용에 관하여 다른 여러 종류의 주식들의 우선적 지위 또는  
		기업이 실패할 경우 위험을 부담하고 성공할 경우 대가를 받는 것.
	우선주
		특별한 공시가 없는 이상 주식회사가 발행하는 주식은
	
32. 자본시장의 형성과정
	자본수요의 양적 확대
		기업의 근대적 생산형식의 도입으로 기업이 대규무화 및 자본수요의 양적 확대를 가져옴
	장기적 자본수요의 확대

33. 자본시장의 경제적 기능
	장기성투자자금의 조달
		운전가금은 단기금융시장을 통해서 조달
		-설비자금은 주식, 사채의 발생에 의한 장기안정적인
		  자금형태로 자본시장을 통해서 조달.
	효율적 자금배분의 기능
	저축수단의 제공
	통화정책의 매개수단
		중앙은행의 통화정책을 실현하는 효율적인 수단.
		기준금리를 변동시키면 자본시장의 기대수익률에 영향을 미치고 기업의 자금조달비용을 변동시켜
		기업의 투자결정에 영향을 미침
	소유와 경영의 분리
		산업화 초기 기업의 창업자와 자금 조달자가 동일
		산업구조 고도화에 따라 기업이 대형화되고 대주주의 소유주식이 분산되어 소유와 경영이 분리
		피셔의 분리정리에 따르면 투자와 저축의...

34. 금융 리스크
	신용 리스크
		거래 상대방의 신용도가 하락하거나 부도가 발생함으로써 생길 수 있는 위험
	시장 리스크
		환률, 금리, 채권 등의 시장가격과 예상변화율이 기대했던 상황과 반대로 움직이는 경우 금융기관이나
		투자가들이 손실을 입을 리스크를 말함
	유동성 리스크
		거래 일방이 일시적인 자금부족으로 인해 정해진 결제시점에서 결제의무를 이행하지 못함으로써 
		거래상대방의 자금조달계획 등에 미치는 손실가능성을 말한다.
	운영 리스크
		회사 내부의 운영에 대한 리스크
	평판 리스크
		회사에 대한 외부의 부정적인 여론때문에 시장에서 신뢰를 상실하여 발생하는 위험을 말함
35. 단리
	단리는 일정한 시기에 오로지 원금에 대해서만 약정한 이자를 붙이는 것.
36. 복리
	복리는 저축과 투자를 통해 이자가 붙으면 이자를 포함해서 이자가 붙는 것.

37. 평균수익률
	수익률의 평균값을 계산할 때에는 복리의 적용여부에 따라 산술평균 또는 기하평균을 사용한다.
		산술평균(복리 미적용)
		기하평균(복리 적용)
38. 수익률
	수익률 계산시 분모값이 달라짐(기저효과)으로 인해 하락수익률과 상승수익률이 미치는 영향은 서로 다르다.

39. 수익률은 투자시점에 따라 사전적 수익률과 사후적 수익률로 명확하게 구별되어 고려해야 한다.
	사전적 수익률: 투자결정 시점에 예상되는 기대수익률로서 리스크에 따라 증가하는 특성을 갖는다.
	사후적 수익률: 투자종료 시점에 계산하는 수익률로서 불확실성 즉 리스크가 없다.
		펀드 가입시 계산된 수익률->사전적 수익률
		펀드 판매시 계산된 수익률	->사후적 수익률
40. 저축과 투자의 차이는 수익률의 불확실성 여부에 따라 구분될 수 있다.
	저축의 수익률
		사전적 수익률 = 사후적 수익률
	투자의 수익률
		사전적 수익률 != 사후적 수익률
41. 장기투자로 갈수록 실제수익률(사후적 수익률)이 기대수익률(사전적 수익률)에 근접해 간다.
	->대수의 법칙
	동전이 앞이 나올 확률은 50%
	->10번 던진경우 vs 1000번 던진 경우

42. 리스크 
	: 불확실성에 노출된 정도를 의미한다.
	투자에서 리스크는 부정적 상황 외에 긍정적 가능성도 내포하며, 영어로 부정적 의미만을 갖는 danger과는 구분된다.
	리스크의 크기는 통계에서 사용하는 분산 또는 표준편차로 측정한다.
	재무학에서는 모든 투자자가 위험회피적이라고 가정하나, 위험회피의 정도는 개인에 따라 차이가 있다고 본다.
	리스크가 클수록 높은 기대수익률이 예상되어야 한다.
		->high risk, high return

43. 포트폴리오
 	포트폴리오란 여러 가지의 모음을 의미하는 말로서 투자에는 여러 가진 자산으로 이루어진 집합체를 가리킨다.
	포트폴리오를 구성하면 분산효과가 발생하여 리스크가 감소한다.
	포트폴리오를 구성하는 자산 간의 상관관계가 낮을수록 분산효과가 커진다.
	포트폴리오의 기대수익률은 구성자산 수익률의 가중평균값이나, 포트폴리오의 리스크는 구성자산간의 상관관계에 따라 분산효과가
	발생하기 떄문에 구성자산 리스크의 가중평균값보다 작은 값이 된다.
		->가중평균값: 예) 주식 80%, 펀드 20%. 이 값에 따라 수익률을 계산함.

44. 자료의 종류
	횡단면 자료
		일정시점에서 하나 이상의 변수에 대해 수집된 자료
		->2009년 전국 15개 시도의 GRDP 자료
	시계열 자료
		일별, 주별, 월별, 분기별 연도별 등 시간에 걸쳐 수집된 자료
		->연도별로 제주지역의 GRDP의 표
	합동 횡단면 자료
		횡단면 자료와 시계열 자료가 합동된 형태
		->
	패널 자료
		동일한 횡단면 단위에 기준을 두고 시간의 흐름에 따라 수집한 자료
		->(특정 가구를 패널로 선택한 다음 매년 그 가구를 대상으로 교육비 지출을 조사한 자료)
	
45. 우리는 주로 시계열 자료를 보게 된다.
46. 변수명
	종속변수    : 독립변수
	설명된 변수 : 설명변수
	예측된 변수 : 예측변수
	피회귀변수  : 회귀변수
	변동변수    : 자극변수
	내생변수    : 외생변수
	통제된변수  : 통제변수
	결과        : 공변변수
##R의 기초
47. 기본 자료형
	숫자형
		정수
		실수
		복소수
	문자형
		큰따옴표로 둘러 쌓아 표현 : "123"
	논리형
	특수한 상태를 나타내는 상수
		NULL
		NA
		-INF,INF
		NaN: 수의 연산에서 불능의 경우 표현
48. 백터
	1:10
	c(1,2,3)
	c(1,2,c(1,2,3))
49. seq
50. rep
	rep(c(1,2,3),times=4) -> 전체에 대한 반복
	rep(c(1,2,3),each=2)  -> 각각에 대한 반복
51. length(x)

52. matrix 요소 가져오기
	>>x <- c(0:10)
	>>x[1]
		[1] 0
	>>x[c(1,2,3)]
		[1] 0 1 2
	>>x[-c(1,2,3)]	
		[1]  3  4  5  6  7  8  9 10
53. matrix 연산
	x <- c(1,2,3,4)
	y <- c(4,5,6,7)
	z <- c(1,2)
	w <- c(1,2,3)#
	x+z	#더 큰 행렬과 연산을 진행하면 갯수를 순환하여 맞춤
	x+w	#만약 행렬의 크기도 다른데 그 크기또한 정수배가 아니라면 연산 못함

54. is.? 함수
	해당 인자의 자료형이 ?이면 true 아니면 false를 반한
55. as.? 함수
	해당 인자를 ?에 해당하는 자료형으로 변환하여 준다.
56. 유용한 함수
	01> x <- 1:5
	01> all(x>3)
		[1] FALSE

	01> any(x>3)
		[1] TRUE
	
	03> height <- c(80,90,70,170)
	03> names(height) <- c("A","B","C","D")
	03> height
	  A   B   C   D 
	 80  90  70 170 

	04> x <- 1:100
	04> head(x)
		[1] 1 2 3 4 5 6
	04> head(x,n=7)
		[1] 1 2 3 4 5 6 7
	04> tail(x)
		[1]  95  96  97  98  99 100
	04> tail(x,n=7)
		[1]  94  95  96  97  98  99 100

	05> sample(10)
		[1]  7  3  5  1  8  9  2  4 10  6
	05> sample(45,6)
		[1] 22  8 35 36 19  1
	05> sample(10,3,replace = TRUE)
		[1] 10  6  3
	05> sample(10,3,prob = (1:10)/55)
		[1] 8 6 4
	05> x <- seq(0,1,by=0.1)
	05> x
		[1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
	05> x[sample(length(x),3)]
		[1] 0.2 0.6 0.3
	05> sample(x,3)
		[1] 0.4 0.3 1.0

	06> x <- c(2,4,-1,3)
	06> which(x>2)
		[1] 2 4
	06> names(x) <- c("a","b","c","d")
	06> which(x>2)
		b d 
		2 4 

	07> arr <- array(1:3,c(2,4))
	07> arr		#부족한 인자는 기존 인자로 순서대로 채움
   			[,1] [,2] [,3] [,4]
		[1,]    1    3    2    1
		[2,]    2    1    3    2
	07> arr[1,]	#행
		[1] 1 3 2 1
	07> arr[,3]	#열
		[1] 2 3

	08> dimnamearr = list(c("A","B"),c("A","B","C","D")) #list 형식으로 행, 열에 대한 이름을 넣어줌
	08> dimnamearr
		[[1]]
		[1] "A" "B"

		[[2]]
		[1] "A" "B" "C" "D"
	08> arr2 <- array(1:3,c(2,4),dimnames = dimnamearr)
	08> arr2
		  A B C D
		A 1 3 2 1
		B 2 1 3 2
	
	09> tmp <- 1:12
	09> tmp
	 	[1]  1  2  3  4  5  6  7  8  9 10 11 12
	09> matrix(tmp,nrow=3)
	   	  [,1] [,2] [,3] [,4]		#default로 열을 우선으로 값을 채움
		[1,]    1    4    7   10
		[2,]    2    5    8   11
		[3,]    3    6    9   12
	09> matrix(tmp,nrow=3,byrow=TRUE)	#행을 우선으로 값을 채운다.
 		    [,1] [,2] [,3] [,4]
		[1,]    1    2    3    4
		[2,]    5    6    7    8
		[3,]    9   10   11   12

	10> v1 <- c(1,2,3,4)
	10> v2 <- c(5,6,7,8)
	10> v3 <- c(9,10,11,12)
	10> cbind(v1,v2,v3)	#column bind
		     v1 v2 v3
		[1,]  1  5  9
		[2,]  2  6 10
		[3,]  3  7 11
		[4,]  4  8 12
	10> rbind(v1,v2,v3)	#row bind
		   [,1] [,2] [,3] [,4]
		v1    1    2    3    4
		v2    5    6    7    8
		v3    9   10   11   12

	11> m1 <- cbind(v1,v2,v3)
	11> m1
 		    v1 v2 v3
		[1,]  1  5  9
		[2,]  2  6 10
		[3,]  3  7 11
		[4,]  4  8 12
	11> apply(m1,1,mean)	#각 행의 평균
		[1] 5 6 7 8
	11> apply(m1,2,mean)	#각 열의 평균
 		 v1   v2   v3 
 		2.5  6.5 10.5 

	12> x <- c(1,2,3,4,5)
	12> factor(x, levels=c(1,2,3,4))
		[1] 1    2    3    4    <NA>
		Levels: 1 2 3 4
	12> factor(x, levels=c(1,2,3,4), exclude = c(1,2))
		[1] <NA> <NA> 3    4    <NA>
		Levels: 3 4
	12> factor(x, levels=c(1,2,3,4), exclude = c(1,2), ordered = TRUE)
		[1] <NA> <NA> 3    4    <NA>
		Levels: 3 < 4

	13> v <- c(1,2,3,4)
	13> x <- factor(v)
	13> is.factor(x)
		[1] TRUE
	13> is.factor(v)
		[1] FALSE
	13> v
		[1] 1 2 3 4
	13> as.factor(v)
		[1] 1 2 3 4
		Levels: 1 2 3 4

	14> score <- c(92,90,82,88,78,64,82,90)
	14> subject <- c("k","k","m","m","m","m","k","k")
	14> tapply(score,subject,mean)
		   k    m 
		88.5 78.0 

	
	15> name <- c("철수","영희","길동")
	15> age <- c(21,20,31)
	15> gender <- factor(c("M","F","M"))
	15> character <- data.frame(name,age,gender)
	15> character
		  name age gender
		1 철수  21      M
		2 영희  20      F
		3 길동  31      M

	16> character
		  name age gender
		1 철수  21      M
		2 영희  20      F
		3 길동  31      M
	16> character$name
		[1] 철수 영희 길동
		Levels: 길동 영희 철수
	16> character[1,]
		  name age gender
		1 철수  21      M
	16> character[c(1,3),]
		  name age gender
		1 철수  21      M
		3 길동  31      M
	16> character[,2]
		[1] 21 20 31
	16> character[3,1]
		[1] 길동
		Levels: 길동 영희 철수

	17> head(airquality)
 		 Ozone Solar.R Wind Temp Month Day
		1    41     190  7.4   67     5   1
		2    36     118  8.0   72     5   2
		3    12     149 12.6   74     5   3
		4    18     313 11.5   62     5   4
		5    NA      NA 14.3   56     5   5
		6    28      NA 14.9   66     5   6
	17> Ozone
		Error: object 'Ozone' not found
	17> attach(airquality)
	17> Ozone[1:5]
		[1] 41 36 12 18 NA
	17> Month[1:5]
		[1] 5 5 5 5 5

	18> head(cars)
		  speed dist
		1     4    2
		2     4   10
		3     7    4
		4     7   22
		5     8   16
		6     9   10
	18> mean(cars$dist)
		[1] 42.98
	18> with(cars, mean(speed))
		[1] 15.4
	18> with(cars, mean(dist))
		[1] 42.98
	
	19> subset(airquality,Temp > 80)
		#dataframe 'airquality' 에서 Temp > 80 조건을 만족하는 것만 출력
	19> subset(airquality,Temp > 80, select = -c(Ozone,Temp))
		#dataframe 'airquality' 에서 Temp > 80 조건을 만족하는 것만 출력, Ozone,Temp 열은 제외
		#만일 +c(Ozone, Temp) 라면 Ozone, Temp 열만 출력
	
	20> str(airquality)
		'data.frame':	153 obs. of  6 variables:
 		$ Ozone  : int  41 36 12 18 NA 28 23 19 8 NA ...
		$ Solar.R: int  190 118 149 313 NA NA 299 99 19 194 ...
 		$ Wind   : num  7.4 8 12.6 11.5 14.3 14.9 8.6 13.8 20.1 8.6 ...
 		$ Temp   : int  67 72 74 62 56 66 65 59 61 69 ...
 		$ Month  : int  5 5 5 5 5 5 5 5 5 5 ...
 		$ Day    : int  1 2 3 4 5 6 7 8 9 10 ...
	20> str(na.omit(airquality))	#na를 제외하고 출력.
		'data.frame':	111 obs. of  6 variables:
		$ Ozone  : int  41 36 12 18 23 19 8 16 11 14 ...
 		$ Solar.R: int  190 118 149 313 299 99 19 256 290 274 ...
 		$ Wind   : num  7.4 8 12.6 11.5 8.6 13.8 20.1 9.7 9.2 10.9 ...
 		$ Temp   : int  67 72 74 62 65 59 61 69 66 68 ...
 		$ Month  : int  5 5 5 5 5 5 5 5 5 5 ...
 		$ Day    : int  1 2 3 4 7 8 9 12 13 14 ...

	21> title <- "My List"
	21> ages <- c(31,41,21)
	21> numbers <- matrix(1:9,nrow=3)
	21> names <- c("Baby","Gentle","none")
	21> listEx <- list(title,ages,numbers,names)
	21> listEx
		[[1]]
		[1] "My List"

		[[2]]
		[1] 31 41 21

		[[3]]
		     [,1] [,2] [,3]
		[1,]    1    4    7
		[2,]    2    5    8
		[3,]    3    6    9

		[[4]]
		[1] "Baby"   "Gentle" "none" 


	22> listEx2 <- list(title=title, age=ages,number=numbers,name=names)
	22> listEx2
		$title
		[1] "My List"

		$age
		[1] 31 41 21

		$number
 		    [,1] [,2] [,3]
		[1,]    1    4    7
		[2,]    2    5    8
		[3,]    3    6    9

		$name
		[1] "Baby"   "Gentle" "none"  

	22> listEx2$title
		[1] "My List"


	23> x <- list(c(1,2,3,4),c(3,2,1))
	23> v <- c(1,2,3,4)
	23> is.list(x)
		[1] TRUE
	23> is.list(v)
		[1] FALSE
	23> a.1 <- as.list(v)
	23> is.list(a.1)
		[1] TRUE

	24> x <- list(a=1:10, beta=exp(-3:3), logic=c(TRUE,FALSE,TRUE,FALSE))
	24> lapply(x,mean)#결과를 list로 반환
		$a
		[1] 5.5

		$beta
		[1] 4.535125

		$logic
		[1] 0.5

	24> sapply(x,mean)#결과를 vector로 반환
		       a     beta    logic 
		5.500000 4.535125 0.500000

	25> ex <- c(1,3,7,NA,12)
	25> ex[ex<10]
		[1]  1  3  7 NA
	25> ex[ex %% 2==0]
		[1] NA 12
	25> ex[is.na(ex)]
		[1] NA

	26> ex[is.na(ex)]
		[1] NA
	26> ex[!is.na(ex)]
		[1]  1  3  7 12
	26> ex[ex%%2==0&!is.na(ex)]
		[1] 12

	27> name <- c("철수","영희","길동")
	27> age <- c(21,20,31)
	27> gender <- factor(c("M","F","M"))
	27> character <- data.frame(name,age,gender)
	27> character[character$gender=="F",]
  		name age gender
		2 영희  20      F
	27> character[character$age<30&character$gender=="M",]
  		name age gender
		1 철수  21      M

	28> x <- c(6:-4)
	28> options(digits = 3)
	28> sqrt(x)	#허수의 등장으로 오류 발생
 		[1] 2.45 2.24 2.00 1.73 1.41 1.00 0.00  NaN  NaN  NaN  NaN
		Warning message:
		In sqrt(x) : NaNs produced
	28> sqrt(ifelse(x>=0,x,NA))	#조건문으로 음수일 경우에는 NA를 반환
		 [1] 2.45 2.24 2.00 1.73 1.41 1.00 0.00   NA   NA   NA   NA

	29> x <- c(1,2,3)
	29> x <- factor(x)
	29> if(is.factor(x)) length(x)	#만일 x의 자료형이 factor이라면 x의 length를 구함
		[1] 3

	30> if(is.factor(x)){	#만일 x가 factor 형이라면
	  +   length(x)		#x의 length를 구하고
	  + }else{		#아니라면
	  +   sum(x)		#x의 합계를 구하라.
	  + }
		[1] 3


	31> if(is.factor(x)){		#x가 factor이라면
	  +   length(x)			#x의 length를 구하라
	  + }else if(is.integer(x)){	#그런데 x가 integer라면
	  +   sum(x)			#x의 합계를 구하라
	  + }else{			#모두 아니라면
	  +   paste(x,"element")	#x를 문자형으로 변환하고 뒤에 "element"를 이어붙여라.
	  + }
		[1] 3

	32> i <- 20
	32> repeat{			#반복
	  +   if(i>25){
	  +     break
	  +   }else{
	  +     print(i)
	  +     i <- i+1
	  +   }
	  + }
		[1] 20
		[1] 21
		[1] 22
		[1] 23
		[1] 24
		[1] 25

	33> dan <- 2
	33> i <- 2
	33> while(i<10){	#i가 20미만일 때까지 반복한다.
	  +   times <- i*dan	
	  +   print(paste(dan,"X",i,"=",times))
	  +   i <- i+1
	  + }
		[1] "2 X 2 = 4"
		[1] "2 X 3 = 6"
		[1] "2 X 4 = 8"
		[1] "2 X 5 = 10"
		[1] "2 X 6 = 12"
		[1] "2 X 7 = 14"
		[1] "2 X 8 = 16"
		[1] "2 X 9 = 18"

	34> dan <- 9		#9단
	34> for(i in 2:9){
	  +   times <- i*dan
	  +   print(paste(dan,"X",i,"=",times))
	  + }
		[1] "9 X 2 = 18"
		[1] "9 X 3 = 27"
		[1] "9 X 4 = 36"
		[1] "9 X 5 = 45"
		[1] "9 X 6 = 54"
		[1] "9 X 7 = 63"
		[1] "9 X 8 = 72"
		[1] "9 X 9 = 81"
	35> str(Puromycin)	#구조 확인
	35> puroUnTrt <- subset(Puromycin, state=="untreated")#state가 untreated인 것만을 골라냄
	35> PuroTrt <- subset(Puromycin, state="treated")	#state가 treated인 것만을 골라냄
	35> plot(rate~conc, data=PuroTrt)
	35> plot(rate~conc, data=puroUnTrt)


















